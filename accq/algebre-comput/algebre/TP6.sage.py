

# This file was *autogenerated* from the file TP6.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1)
print("""\
# *************************************************************************** #
# *************************************************************************** #
# TP6 : BASES DE GROEBNER ET SYSTEMES POLYNOMIAUX MULTIVARIES                 #
# *************************************************************************** #
# *************************************************************************** #
""")

# CONSIGNES
#
# Les seules lignes a modifier sont annoncee par "Code pour l'exercice"
# indique en commmentaire et son signalees
# Ne changez pas le nom des variables
#
# CONSEILS
#
# Ce modele vous sert a restituer votre travail. Il est deconseille d'ecrire
# une longue suite d'instruction et de debugger ensuite. Il vaut mieux tester
# le code que vous produisez ligne apres ligne, afficher les resultats et
# controler que les objets que vous definissez sont bien ceux que vous attendez.
#
# Vous devez verifier votre code en le testant, y compris par des exemples que
# vous aurez fabrique vous-meme.
#


print("""\
# ****************************************************************************
#  FONCTIONS DE SAGEMATH
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_3 , order='lex', names=('x', 'y', 'z',)); (x, y, z,) = MPol._first_ngens(3)
f = _sage_const_2 *x**_sage_const_2 *y+_sage_const_7 *z**_sage_const_3 

# Code pour l'EXERCICE

print(x<y**_sage_const_2 )
print(f.lt())
print(f.lc())
print(f.lm())

reponse  = """
f.lt() renvoie le terme dominant (leading term)
f.lc() renvoie le coefficient du terme dominant (leading coefficient)
f.lm() renvoie le monome dominant (leading monomial)

On a donc lt = lc * lm

Les autres ordres monomiaux implémentés dans SageMath sont :
- lexicographique (lex)
- degré lexicographique (deglex) -> degrés décroissants puis ordre lexicographique si égalité
- degrevlex
- invlex
"""

# # Affichage des resultats

print("\n$1/ ", reponse)


print("""\
# ****************************************************************************
# DIVISION MULTIVARIEE
# ****************************************************************************
""")




# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_2 , order='lex', names=('x', 'y',)); (x, y,) = MPol._first_ngens(2)
f  = -x**_sage_const_7  + x**_sage_const_6 *y + _sage_const_2 *x**_sage_const_5  - _sage_const_2 *x**_sage_const_4 *y - _sage_const_5 *x**_sage_const_2  + _sage_const_3 *x*y**_sage_const_3  + _sage_const_5 *x*y + _sage_const_11 *y**_sage_const_3  + _sage_const_10  
f1 = x*y**_sage_const_2 +_sage_const_2 *y**_sage_const_2 
f2 = x**_sage_const_5 +_sage_const_5 

# Code pour l'EXERCICE

def myDivision(f,F):
    MPol = f.parent()
    n = MPol.ngens()
    s = len(F) 
    # F est la liste des fi
    Q = [MPol(_sage_const_0 )]*s # liste des qi
    r = _sage_const_0 
    p = f
    while p != _sage_const_0  :
        exists = false
        for i in range (s) :
            if p.lt() % F[i].lt() == _sage_const_0  :
                exists = true 
                Q[i] += p.lt() // F[i].lt()
                p -= (p.lt() // F[i].lt()) * F[i]
                break
        if not exists :
            r += p.lt()
            p -= p.lt()
    assert(f==sum(q*g for q,g in zip(Q,F) )+r)
    return Q,r

# # Affichage des resultats

print("$ ",  myDivision(f,[f1,f2]))
print()


print("""\
# ****************************************************************************
# BASE DE GROEBNER
# ****************************************************************************
""")

# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_3 , order='lex', names=('x', 'y', 'z',)); (x, y, z,) = MPol._first_ngens(3)
f1 = x**_sage_const_2 -y
f2 = x*y-z
f3 = z**_sage_const_4 +x*y

# Code pour l'EXERCICE

def syzyg(g, h) :
    tdg = g.lt()
    tdh = h.lt()
    p = lcm(tdg, tdh)
    return (p // tdg) * g - (p // tdh) * h

def myGroebner(F):
    G = F 
    while True :
        S = []
        for g in G :
            for h in G :
                # print(syzyg(g, h))
                Q, r = myDivision(syzyg(g, h), G)
                if r != _sage_const_0  :
                    S.append(r)
        G += S
        if S == [] :
            break 
    return G
    
def myRedGroebner(F):
    G = myGroebner(F)
    while True :
        exists = False 
        for g in G :
            G_prive_g = [h for h in G if h != g] 
            Q, r = myDivision(g, G_prive_g)
            if r == _sage_const_0  :
                G = G_prive_g
                exists = True 
                break
        if not exists :
            break 
    return G

# # Affichage des resultats

print("\n$1/ ",myGroebner([f1,f2,f3]))
print("\n$2/ ",myRedGroebner([f1,f2,f3]))
I = MPol.ideal([f1,f2,f3])
print("\nBase de Grobner donnée par Sage Math :\n",I.groebner_basis())




print()
print("""\
# ****************************************************************************
# APPARTENANCE A UN IDEAL
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_3 , order='lex', names=('x', 'y', 'z',)); (x, y, z,) = MPol._first_ngens(3)
f1 = x*y-y**_sage_const_2 
f2 = x**_sage_const_3 -z**_sage_const_2 
I = Ideal([f1,f2])
f = -_sage_const_4 *x**_sage_const_2 *y**_sage_const_2 *z**_sage_const_2  + y**_sage_const_6  + _sage_const_3 *z**_sage_const_5 

# Code pour l'EXERCICE

G = myGroebner([f1, f2])
Q, r = myDivision(f, G)

test1 = f in I
test2 = (r == _sage_const_0 )  # on vérifie que le reste vaut 0


# # Affichage des resultats

print("$ Test de Sage :",test1)
print("$ Test personnel :",test2)
print("On vérifie pour notre test personnel que le reste donné vaut bien 0, en utilisant la base fournie par notre implémentation de myGrobner")
print()


print("""\
# ****************************************************************************
# RESOLUTION D'UN SYSTEME
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice


MPol = PolynomialRing(QQ,_sage_const_2 , names=('x', 'y',)); (x, y,) = MPol._first_ngens(2)# QUEL ORDRE DEVEZ-VOUS CHOISIR ?
f = (y**_sage_const_2 +_sage_const_6 )*(x-_sage_const_1 ) - y*(x**_sage_const_2  + _sage_const_1 )
g = (x**_sage_const_2 +_sage_const_6 )*(y-_sage_const_1 ) - x*(y**_sage_const_2  + _sage_const_1 )
 

# Code pour l'EXERCICE
I = Ideal([f,g])
base = I.groebner_basis()

S = PolynomialRing(QQ, 'y')  # Anneau univarié en y
y_univar = S.gen()
f_univar = S(base[_sage_const_0 ])  # Conversion
racines_y = f_univar.roots() 
racines  = [(_sage_const_2 , _sage_const_2 ), (_sage_const_2 , _sage_const_3 ), (_sage_const_3 , _sage_const_3 ), (_sage_const_3 , _sage_const_2 )]

Gf = implicit_plot(f,(x,_sage_const_0 ,_sage_const_6 ),(y,_sage_const_0 ,_sage_const_6 ),color='red') 
Gg = implicit_plot(g,(x,_sage_const_0 ,_sage_const_6 ),(y,_sage_const_0 ,_sage_const_6 ),color='blue')  
Gp = point2d(racines,color='green')
combined_plot = Gf + Gg + Gp

# # Affichage des resultats

print("\n$1/  Une base de Groebner de [f,g] est", base)
print("On remarque que l'un des polynômes est seulement une fonction de y")
print("\n$2/  Les valeurs de y sont", racines_y)
print("\n$4/  Les valeurs de (x,y) sont", racines)
print("\n$4/ Le graphique est stocké dans courbes_implicites.png")


combined_plot.show()
combined_plot.save("courbes_implicites.png")
print()


print("""\
# ****************************************************************************
# OPTIMISATION
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice


MPol = PolynomialRing(QQ,_sage_const_3 , order='invlex', names=('x', 'y', 'z',)); (x, y, z,) = MPol._first_ngens(3)# QUEL ORDRE DEVEZ-VOUS CHOISIR ?
f = x**_sage_const_2 *y  - _sage_const_2 *x*y + y + _sage_const_1 
g = x**_sage_const_2  + y**_sage_const_2  - _sage_const_1 


# Code pour l'EXERCICE

syst = [g, x*y-y-x*z, x**_sage_const_2 -_sage_const_2 *x+_sage_const_1 -_sage_const_2 *y*z]
base = Ideal(syst).groebner_basis()
racines = [(_sage_const_1 , _sage_const_0 ), (-_sage_const_2 /_sage_const_3 , sqrt(_sage_const_5 )/_sage_const_3 ), (-_sage_const_2 /_sage_const_3 , -sqrt(_sage_const_5 )/_sage_const_3 )]


# # Affichage des resultats

print("\n$1/  On doit resoudre le systeme", syst)
print("J'ai posé lambda = z pour pouvoir écrire les équations plus facilement")
print("\n$2/  dont une base de Groebner est", base)
print("En prenant l'ordre invlex (inverse lexicographique), on a un des polnyômes de la base que l'on écrit : x^3 - 4/3*x^2 - 1/3*x + 2/3 = 1/3*(x-1)^2(3x+2) donc x=1 ou x=-2/3")
print("Si x=1, on a y=0 et z=0, donc (x, y) = (1, 0)")
print("Si x=-2/3, on a y^2 = 5/9 et donc (x, y) = (-2/3, +-sqrt(5)/3) par analyse faite sur papier") 
print("\n$4/  Les valeurs de (x,y) sont", racines)
print()

print("""\
# ****************************************************************************
# MANIPULATIONS ALGEBRIQUES
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

# Code pour l'EXERCICE


MPol = PolynomialRing(QQ,_sage_const_4 ,order='lex', names=('x', 'y', 'u', 'v',)); (x, y, u, v,) = MPol._first_ngens(4)
f = x**_sage_const_2  + y**_sage_const_2  - _sage_const_1 
g = x + y - u
h = _sage_const_2 *x*y + _sage_const_1  - _sage_const_2 *x**_sage_const_2  - v
I = Ideal(f, g, h)
base = I.reduce(y**_sage_const_6 )
# # Affichage des resultats

print("$1/", base)
print()


print("""\
# ****************************************************************************
# OVALES DE DESCARTES
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice


# Code pour l'EXERCICE

MPol = PolynomialRing(QQ,_sage_const_4 ,order='invlex', names=('x', 'y', 'w', 'z',)); (x, y, w, z,) = MPol._first_ngens(4)
f = w+_sage_const_2 *z-_sage_const_3 
g = w**_sage_const_2  - (x**_sage_const_2  + y**_sage_const_2 )
h = z**_sage_const_2  - ((x-_sage_const_1 )**_sage_const_2  + y**_sage_const_2 )
I = Ideal(f,g,h)
base = I.groebner_basis()

equation = base[_sage_const_2 ]

# # Affichage des resultats

print("$ L'équation est ",base)


MPol2 = PolynomialRing(QQ,_sage_const_2 ,order='lex', names=('x', 'y',)); (x, y,) = MPol2._first_ngens(2)

print("\n$ L'équation est ",equation,"= 0")
p1 = implicit_plot(MPol2(equation),(x,-_sage_const_5 ,_sage_const_5 ),(y,-_sage_const_5 ,_sage_const_5 ))
p1.save("ovales-descartes.png")

