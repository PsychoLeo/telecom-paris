

# This file was *autogenerated* from the file TP7.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_10 = Integer(10); _sage_const_3 = Integer(3); _sage_const_40 = Integer(40); _sage_const_32 = Integer(32); _sage_const_115 = Integer(115); _sage_const_136 = Integer(136); _sage_const_48 = Integer(48); _sage_const_0 = Integer(0); _sage_const_12 = Integer(12); _sage_const_6 = Integer(6); _sage_const_1 = Integer(1); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_9 = Integer(9); _sage_const_11 = Integer(11); _sage_const_25 = Integer(25); _sage_const_117 = Integer(117)
print("""\
# *************************************************************************** #
# *************************************************************************** #
# TP7 : APPLICATIONS CHOISIES DES BASES DE GROEBNER                           #
# *************************************************************************** #
# *************************************************************************** #
""")

# CONSIGNES
#
# Les seules lignes a modifier sont annoncee par "Code pour l'exercice"
# indique en commmentaire et son signalees
# Ne changez pas le nom des variables
#
# CONSEILS
#
# Ce modele vous sert a restituer votre travail. Il est deconseille d'ecrire
# une longue suite d'instruction et de debugger ensuite. Il vaut mieux tester
# le code que vous produisez ligne apres ligne, afficher les resultats et
# controler que les objets que vous definissez sont bien ceux que vous attendez.
#
# Vous devez verifier votre code en le testant, y compris par des exemples que
# vous aurez fabrique vous-meme.
#



print("""\
# ****************************************************************************
# POINTS SINGULIERS 
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_2 , names=('x', 'y',)); (x, y,) = MPol._first_ngens(2)
f = _sage_const_5 *x**_sage_const_4  - _sage_const_10 *x**_sage_const_3  + _sage_const_10 *x**_sage_const_2 *y**_sage_const_2  - _sage_const_40 *x**_sage_const_2 *y + _sage_const_40 *x**_sage_const_2  - _sage_const_10 *x*y**_sage_const_2  + _sage_const_40 *x*y - _sage_const_32 *x + _sage_const_5 *y**_sage_const_4  - _sage_const_40 *y**_sage_const_3  + _sage_const_115 *y**_sage_const_2  - _sage_const_136 *y + _sage_const_48 

dfx = diff(f, x)
dfy = diff(f, y)

I = Ideal(f, dfx, dfy)
base = I.groebner_basis()

print("On trouve la base de Groebner associée au système :", base)
print("On calcule à la main les racines du premier polynôme (qui est en y uniquement)", base[_sage_const_0 ])
print("On trouve y=12/5, x=3/4y-1=4/5")

# Code pour l'EXERCICE

PtsSinguliers = [(_sage_const_4 /_sage_const_5 , _sage_const_12 /_sage_const_5 )] # A calculer


# # Affichage des resultats

print("La liste des points d'inflexions est :",PtsSinguliers)
G1 = implicit_plot(f,(x,-_sage_const_2 ,_sage_const_6 ),(y,-_sage_const_2 ,_sage_const_6 ),color='blue')
G2 = points(PtsSinguliers,color='red')
show(G1+G2)

G = G1+G2 
G.save("ex267-pt-singuliers.png")
print()


print("""\
# ****************************************************************************
#  VALUATIONS
# ****************************************************************************
""")

A = AffineSpace(QQ, _sage_const_3 , names=('x', 'y', 'z',)); (x, y, z,) = A._first_ngens(3)
QQ5 = QuadraticField(_sage_const_5 , names=('rac5',)); (rac5,) = QQ5._first_ngens(1)
f1 = x**_sage_const_2 +y**_sage_const_2 -_sage_const_1 
f2 = _sage_const_5 *x-(z-_sage_const_3 )**_sage_const_2 
Z = Curve([f1,f2],A)
n = z**_sage_const_2 -_sage_const_6 *z+_sage_const_5 
d = x**_sage_const_2 -x+y**_sage_const_2 

# Code pour l'EXERCICE

crossprod = vector(f1.gradient()).cross_product(vector(f2.gradient()))
I = Ideal(f1,f2,crossprod[_sage_const_0 ],crossprod[_sage_const_1 ],crossprod[_sage_const_2 ])
basis = I.groebner_basis()

print("1) La courbe Z(R) restreinte à x>=0 correspond exactement à Z1")

reponse2="La variété est lisse car la base de groebner vaut [1] et le produit vectoriel ne s'annule pas sur la courbe"

I = Ideal(f1,f2,n)
basis = I.groebner_basis()
zeros_without_mult = [(x,y,z) for x,_ in basis[_sage_const_2 ].univariate_polynomial().roots(QQ5) for y,_ in basis[_sage_const_0 ].univariate_polynomial().roots(QQ5) for z,_ in basis[_sage_const_1 ].univariate_polynomial().roots(QQ5)]
deg = f1.degree()*f2.degree()*n.degree()
zeros=[]
for (xx,yy,zz) in zeros_without_mult :
    v = (x - xx) + (y - yy) + (z - zz)
    v = v**deg
    I = Ideal(f1,f2,n,v)
    ordre = len(I.normal_basis())
    zeros.append(((xx,yy,zz),ordre))


I = Ideal(f1,f2,d)
basis = I.groebner_basis()
poles_without_mult = [(x,y,z) for x,_ in basis[_sage_const_2 ].univariate_polynomial().roots(QQ5) for y,_ in basis[_sage_const_0 ].univariate_polynomial().roots(QQ5) for z,_ in basis[_sage_const_1 ].univariate_polynomial().roots(QQ5)]
poles = []
for (xx,yy,zz) in poles_without_mult :
    v = (x - xx) + (y - yy) + (z - zz)
    v = v**deg
    I = Ideal(f1,f2,d,v)
    ordre = len(I.normal_basis())
    poles.append(((xx,yy,zz),ordre))

var('theta')
__tmp__=var("theta"); x = symbolic_expression(sin(theta)).function(theta)
__tmp__=var("theta"); y = symbolic_expression(cos(theta)).function(theta)
__tmp__=var("theta"); z = symbolic_expression(_sage_const_3  + sqrt(_sage_const_5 *sin(theta))).function(theta)
Z1 = parametric_plot3d((x,y,z),(theta,_sage_const_0 ,pi))  

var('theta')
__tmp__=var("theta"); x = symbolic_expression(sin(theta)).function(theta)
__tmp__=var("theta"); y = symbolic_expression(cos(theta)).function(theta)
__tmp__=var("theta"); z = symbolic_expression(_sage_const_3  - sqrt(_sage_const_5 *sin(theta))).function(theta)
Z2 = parametric_plot3d((x,y,z),(theta,_sage_const_0 ,pi)) 

G = Z1 + Z2
show(G)
G.save("parametric-curves-ex277.png")

print(reponse2)
print("Confirmation de la lissité de la courbe : ", Z.is_smooth())

print("L'ensemble des zeros munis de leur multiplicité de h est",zeros)
print("L'ensemble des poles munis de leur multiplicité de h est",poles)
print()


print("""\
# ****************************************************************************
#  ENVELOPPE
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_3 ,order="invlex", names=('x', 'y', 't',)); (x, y, t,) = MPol._first_ngens(3)# ORDRE DES VARIABLES A FIXER
f = (x-t)**_sage_const_2 +(y+t**_sage_const_2 -_sage_const_4 *t)**_sage_const_2 -_sage_const_4 

# Code pour l'EXERCICE

reponse1 = "La courbe (Ct) est un cercle dont le centre décrit une parabole quand t varie"

deriv = f.derivative(t)
I = Ideal(f,deriv)

basis = I.groebner_basis()

eq_enveloppe = basis[-_sage_const_1 ]
__tmp__=var("x,y"); env = symbolic_expression(eq_enveloppe).function(x,y)

reponse4 = "Les billes frôlent le toit mais ne le tapent pas"

# # Affichage des resultats

print(reponse1)

print("L'enveloppe de la famille de courbe a pour equation",eq_enveloppe)
G = implicit_plot(env,(x,-_sage_const_5 ,_sage_const_7 ),(y,-_sage_const_5 ,_sage_const_7 ))
D = implicit_plot(x+_sage_const_5 -y,(x,-_sage_const_5 ,_sage_const_7 ),(y,-_sage_const_5 ,_sage_const_7 ))
show(G+D)

print("La bille expulsée tape-t-elle le toit ?", reponse4)
print()


print("""\
# ****************************************************************************
#  COLORATION DE GRAPHES
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

G= Graph(_sage_const_12 )
G.add_cycle(range(_sage_const_8 ))
G.add_edges([(i,i+_sage_const_4 ) for i in range(_sage_const_4 ) ])
G.add_edges([(_sage_const_8 ,_sage_const_5 ),(_sage_const_8 ,_sage_const_7 ),(_sage_const_9 ,_sage_const_0 ),(_sage_const_9 ,_sage_const_2 ),(_sage_const_10 ,_sage_const_1 ), (_sage_const_10 ,_sage_const_3 ),(_sage_const_11 ,_sage_const_4 ),(_sage_const_11 ,_sage_const_6 ) ])
G.add_edges([(_sage_const_8 ,_sage_const_9 ),(_sage_const_9 ,_sage_const_10 ),(_sage_const_10 ,_sage_const_11 )])
G.show()
G.coloring()

MPol = PolynomialRing(QQ,_sage_const_12 ,'x',
order = 'invlex')
__tmp__=var("v"); phi = symbolic_expression(v**_sage_const_3 -_sage_const_1 ).function(v)
__tmp__=var("u,v"); psi = symbolic_expression(u**_sage_const_2 +u*v+v**_sage_const_2 ).function(u,v)
IG= Ideal(MPol, [phi(MPol.gen(v)) for v in G.vertices()] + [psi(MPol.gen(u),MPol.gen(v)) for (u,v) in G.edges(labels=false)])

# Code pour l'EXERCICE

reponse1 = len(G.coloring())
base = IG.groebner_basis()
reponse3 = "La base de Groebner triangularise le système, et ne laisse pas de liberté pour la manière de colorier le graphe"

# # Affichage des resultats

print("Il faut",reponse1,"couleurs pour colorer ce graphe")
print("Une base de Groebner de I(G,3) est", base)
print(reponse3)
print()


print("""\
# ****************************************************************************
#  PREUVE DE THEOREMES GEOMETRIQUES
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_4 , names=('x', 'y', 'u', 'v',)); (x, y, u, v,) = MPol._first_ngens(4)


# Code pour l'EXERCICE

IA = Ideal(MPol,[(_sage_const_1 +u)*y - v*x])
IB = Ideal(MPol,[(u-_sage_const_2 )*y-v*(x-_sage_const_1 )])
IC = Ideal(MPol,[(_sage_const_2 *u-_sage_const_1 )*y-_sage_const_2 *v*(x-_sage_const_1 /_sage_const_2 )])

reponse2  = "\nLes zéros des polynomes de l'idéal somme sont exactement le point d'intersection des médianes issues de A et B"

reponse4 = "\nOn vient de remontrer que les trois médianes d'un triangle sont concourantes"

# # Affichage des resultats

print("Les idéaux IA, IB et IC sont", IA, IB, IC)
print(reponse2)
print("\nSi on réduit (2*u-1)*y-2*v*(x-1/2) modulo IA+IB, on obtient : ", ((_sage_const_2 *u-_sage_const_1 )*y-_sage_const_2 *v*(x-_sage_const_1 /_sage_const_2 )).reduce(IA+IB))
print("Cela signifie que la droite deltaC passe par le point d'intersection des droites engendrant IA et IB, ie par l'intersection de deltaA et deltaB")
print(reponse4)
print()




print("""\
# ****************************************************************************
#  PROGRAMMATION ENTIERE
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_4 ,order="deglex", names=('p', 'n', 'd', 'q',)); (p, n, d, q,) = MPol._first_ngens(4)
I=Ideal([p**_sage_const_5 -n,p**_sage_const_10 -d,p**_sage_const_25 -q])

# Code pour l'EXERCICE

base = I.groebner_basis()
reponse2 = """Le minimum est donné par p=2, n=1, d=1 et q=4, ce qui correspond aux exposants de la réduction\
de p^177 modulo I. Cela fonctionne car on a choisi l'ordre degré lexicographique, donc la réduction va en priorité\
\"convertir\" le plus de puissances de p en puissances de n, puis les puissances de n en puissances de d etc."""

# # Affichage des resultats

print("Base de Groebner",base)
print((p**_sage_const_117 ).reduce(I))
print(reponse2)
print()


print("""\
# ****************************************************************************
#  SURFACE DE CLEBSCH
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_3 , names=('x1', 'x2', 'x3',)); (x1, x2, x3,) = MPol._first_ngens(3)
f=x1**_sage_const_3 +x2**_sage_const_3 +x3**_sage_const_3 +_sage_const_1 -(x1+x2+x3+_sage_const_1 )**_sage_const_3 

# Code pour l'EXERCICE

MMPol = PolynomialRing(QQ,_sage_const_7 ,order="invlex", names=('a', 'b', 'c', 'd', 'e', 'f', 't',)); (a, b, c, d, e, f, t,) = MMPol._first_ngens(7)

# on substitue pour t non infini
eq1 = _sage_const_1 **_sage_const_3  + t**_sage_const_3  + (a+d*t)**_sage_const_3  + (b+e*t)**_sage_const_3  + (c+f*t)**_sage_const_3 
eq2 = _sage_const_1  + t + a +d*t + b + e*t + c + f*t 
# et pour t=+inf
eq3 = _sage_const_0 **_sage_const_3  + _sage_const_1 **_sage_const_3  + d**_sage_const_3  + e**_sage_const_3  + f**_sage_const_3 
eq4 = _sage_const_0  + _sage_const_1  + d + e + f

I = Ideal(eq1,eq2,eq3,eq4)
basis = I.groebner_basis()

# # Affichage des resultats

print("$1/ Cette surface correspond aux points X1 X2 et X3 de la surface en fixant X4 = 1")

