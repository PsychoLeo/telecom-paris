

# This file was *autogenerated* from the file tp9.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_11 = Integer(11); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_100 = Integer(100); _sage_const_6 = Integer(6); _sage_const_4 = Integer(4); _sage_const_12 = Integer(12); _sage_const_10 = Integer(10); _sage_const_222763 = Integer(222763); _sage_const_1323269 = Integer(1323269); _sage_const_1000 = Integer(1000); _sage_const_2886 = Integer(2886)
print("""\
# *************************************************************************** #
# *************************************************************************** #
# TP9 : FACTORISATION DES ENTIERS                                             #
# *************************************************************************** #
# *************************************************************************** #
""")

from sage.matrix.constructor import Matrix

# CONSIGNES
#
# Les seules lignes a modifier sont annoncee par "Code pour l'exercice"
# indique en commmentaire et son signalees
# Ne changez pas le nom des variables
#
# CONSEILS
#
# Ce modele vous sert a restituer votre travail. Il est deconseille d'ecrire
# une longue suite d'instruction et de debugger ensuite. Il vaut mieux tester
# le code que vous produisez ligne apres ligne, afficher les resultats et
# controler que les objets que vous definissez sont bien ceux que vous attendez.
#
# Vous devez verifier votre code en le testant, y compris par des exemples que
# vous aurez fabrique vous-meme.
#



print("""\
# ****************************************************************************
# DIVISEURS SUCCESSIFS
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

n=_sage_const_2 *_sage_const_3 *_sage_const_3 *_sage_const_5 *_sage_const_5 *_sage_const_5 *_sage_const_7 *_sage_const_11 *_sage_const_11 

# Code pour l'EXERCICE

def div_successives(n):
    ans = []
    d = _sage_const_2 
    while d*d <=n :
        while n % d == _sage_const_0  :
            n //= d 
            if ans == [] or ans[-_sage_const_1 ] != d : 
                ans.append(d)
        d += _sage_const_1 
    if n > _sage_const_1  :
        ans.append(n)
    return ans

# # Affichage des resultats

print("Q1 :", div_successives(n))
for n in range(_sage_const_2 ,_sage_const_100 ):
    # print(ZZ(n).prime_divisors())
    assert(div_successives(ZZ(n))==ZZ(n).prime_divisors())

print()
print("Q2 : La ligne d <- d+1 donne un algorithme de complexité O(sqrt n) car on va itérer à travers tous les d <= sqrt(n), donc son efficacité pourrait être améliorée.")
print()
print("Q3 : Il faut trouver le nombre de nombres premiers avec p1...pk et inférieurs à sqrt(n). On peut dire que cela est environ égal à sqrt(n)/p1...pk * PHI(p1...pk) où PHI est la fonction indicatrice d'euler. En effet, on prend le nombre de nombres premiers avec p1...pk inférieurs à p1...pk avec PHI(p1...pk) puis on le multiplie par le rapport sqrt(n)/p1...pk pour 'approximer' le résultat et compter tous ceux plus petits que sqrt(n). Par recherche sur internet, on trouve que PHI(n)/n <= 6/pi^2 donc l'algorithme s'execute en moins de 0.6 * sqrt(n) itérations.")
print()

def div_successives_opt(n) :
    ans = []
    p = [_sage_const_2 , _sage_const_3 ]
    if n % _sage_const_2  == _sage_const_0  :
        ans.append(_sage_const_2 )
        while n % _sage_const_2  == _sage_const_0  :
            n //= _sage_const_2 
    if n % _sage_const_3  == _sage_const_0  :
        ans.append(_sage_const_3 )
        while n % _sage_const_3  == _sage_const_0  :
            n //= _sage_const_3 
    d = _sage_const_5  # on va désormais seulement prendre les nombre congrus à 1 ou 5 mod 6 ie ceux premiers avec 2 et 3 et inférieurs à sqrt(n)
    while d*d <= n :
        while n % d == _sage_const_0  :
            n //= d 
            if ans == [] or ans[-_sage_const_1 ] != d : 
                ans.append(d)
        if d % _sage_const_6  == _sage_const_5  :
            d += _sage_const_2 
        else :
            d += _sage_const_4 
    if n > _sage_const_1  :
        ans.append(n)
    return ans

n=_sage_const_2 *_sage_const_3 *_sage_const_3 *_sage_const_5 *_sage_const_5 *_sage_const_5 *_sage_const_7 *_sage_const_11 *_sage_const_11 
print("Q4 :", div_successives_opt(n))
for n in range(_sage_const_2 ,_sage_const_100 ):
    # print(ZZ(n).prime_divisors())
    assert(div_successives_opt(ZZ(n))==ZZ(n).prime_divisors())
print()


print("""\
# ****************************************************************************
# FACTORISATION D'UN NOMBRE B-FRIABLE
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

n=_sage_const_2 *_sage_const_3 *_sage_const_3 *_sage_const_5 *_sage_const_5 *_sage_const_5 *_sage_const_7 *_sage_const_11 *_sage_const_11 
P=[p for p in primes(_sage_const_12 )]

# Code pour l'EXERCICE

def div_successives_friable(n, P):
    ans = []
    for pi in P :
        if n % pi == _sage_const_0  :
            ans.append(pi)
        while n % pi == _sage_const_0  :
            n //= pi
    return ans

# # Affichage des resultats

print(div_successives_friable(n,P))
for n in range(_sage_const_2 ,_sage_const_10 ):
    assert(div_successives_friable(ZZ(n),P)==ZZ(n).prime_divisors())
print()


print("""\
# ****************************************************************************
# RHO DE POLLARD
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

n=_sage_const_222763 

# Code pour l'EXERCICE

def myPollardrho(n):
    x=Integers(n).random_element()
    y = x 
    f = lambda x: (x**_sage_const_2 +_sage_const_1 )%n 
    g = _sage_const_1 
    while g == _sage_const_1  :
        x = f(x)
        y = f(f(y))
        g = gcd(x-y, n)
    if g == n :
        return _sage_const_1 
    return g

# # Affichage des resultats

print(myPollardrho(n))

for _ in range(_sage_const_5 ):
    n=ZZ.random_element(_sage_const_3 ,_sage_const_100 )
    print(n, 
      "| Resultat rho de Pollard : ", 
      myPollardrho(n), 
      " | n est-il composé ?",not n.is_prime())

print()


print("""\
# ****************************************************************************
# P-1 DE POLLARD
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

n=_sage_const_1323269 
# print(ZZ(n).prime_divisors())

# Code pour l'EXERCICE

def myPollardpm1(n,B, nb_test=_sage_const_100 ):
    for _ in range (nb_test) :
        a = randint(_sage_const_2 ,n-_sage_const_2 )
        g = gcd(n,a)
        if g > _sage_const_1  : 
            return g
        for p in primes(B) :
            e = int(log(B)/log(p))
            a = power_mod(a, p**e, n)
        g = gcd(a-_sage_const_1 ,n)
        if _sage_const_1  < g < n :
            return g
    return _sage_const_1 


# # Affichage des resultats

print(myPollardpm1(n, _sage_const_1000 ))

for _ in range(_sage_const_5 ):
    n=ZZ.random_element(_sage_const_3 ,_sage_const_100 )
    print(n, 
      "| Resultat p-1 de Pollard : ", 
      myPollardpm1(n, _sage_const_100 ), 
      " | n est-il composé ?",not n.is_prime())
print()



print("""\
# ****************************************************************************
# CRIBLE QUADRATIQUE
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

n=_sage_const_2886 

# Code pour l'EXERCICE

def L(n) :
    return exp(sqrt(ln(n) * ln(ln(n))))

def B_friable(n, B) :
    pr = prime_divisors(n)
    return pr[-_sage_const_1 ] <= B

def cribleQuadratique (n):
    B = ceil(sqrt(L(n)))
    pr = list(primes(B))
    m = len(pr)
    x = ceil(sqrt(n))
    S = []
    while len(S) < m+_sage_const_1  :
        a = (x*x) % n 
        if B_friable(a, B) :
            S.append((x, a))
        x += _sage_const_1 
    F2 = GF(_sage_const_2 )
    M = Matrix(F2, m, m+_sage_const_1 )
    for i in range (m+_sage_const_1 ) :  
        x, a = S[i]
        for j in range (m) :
            while a % pr[j] == _sage_const_0  :
                a /= pr[j]
                M[j, i] += _sage_const_1 
    v = M.right_kernel().basis()[_sage_const_0 ]
    K = v.support()
    # print(K)
    z = _sage_const_1 
    for i in K :
        x, a = S[i]
        z = (z * x) % n 
    y = _sage_const_1 
    for i in range (m) :
        s = Integer(_sage_const_0 )
        for j in K :
            s += Integer(M[i, j])
        s //= _sage_const_2 
        y = (y * (pr[i]**s)) % n 
    d = gcd(z-y, n)
    return d

# # Affichage des resultats
print("Un diviseur de", n, "trouvé avec le crible quadratique est :")
print(cribleQuadratique(n))
print()

