

# This file was *autogenerated* from the file TP5.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_6 = Integer(6); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_100 = Integer(100); _sage_const_10 = Integer(10); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_13 = Integer(13); _sage_const_12 = Integer(12); _sage_const_8 = Integer(8); _sage_const_11 = Integer(11); _sage_const_7626 = Integer(7626)
print("""\
# *************************************************************************** #
# *************************************************************************** #
# TP5 : FACTORISATION COMPLETE DE POLYNOMES UNIVARIEES                        #
# *************************************************************************** #
# *************************************************************************** #
""")

# CONSIGNES
#
# Les seules lignes a modifier sont annoncee par "Code pour l'exercice"
# indique en commmentaire et son signalees
# Ne changez pas le nom des variables
#
# CONSEILS
#
# Ce modele vous sert a restituer votre travail. Il est deconseille d'ecrire
# une longue suite d'instruction et de debugger ensuite. Il vaut mieux tester
# le code que vous produisez ligne apres ligne, afficher les resultats et
# controler que les objets que vous definissez sont bien ceux que vous attendez.
#
# Vous devez verifier votre code en le testant, y compris par des exemples que
# vous aurez fabrique vous-meme.
#



print("""\
# ****************************************************************************
# BERLEKAMP
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

F3 = FiniteField(_sage_const_3 )
Pol3 = PolynomialRing(F3, names=('x',)); (x,) = Pol3._first_ngens(1)
f = x**_sage_const_3  - x**_sage_const_2  - _sage_const_1 

# Code pour l'EXERCICE

x3 = x**_sage_const_3  % f
x6 = x**_sage_const_6  % f
Q = matrix(F3,[[_sage_const_1 , _sage_const_1 , _sage_const_2 ], [_sage_const_0 , _sage_const_0 , _sage_const_1 ], [_sage_const_0 , _sage_const_1 , _sage_const_0 ]]) # on trouve cela par application directe de l'écriture de Q donnée dans l'algorithme 12

b1 = vector(F3,[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ])
b2 = vector(F3,[_sage_const_0 ,_sage_const_1 ,_sage_const_1 ])
# c'est une base car le rang de la matrice Q-I est 1


print("\n$1a/ x^3 vaut",x3," et x^6 vaut",x6)
print("La matrice de Petr Berlekamp est")
print(Q)

print("\n$1b/ On a Q * b1 - b1 = ")
print(Q*b1-b1)
print("et Q * b2 - b2 = ")
print(Q*b2-b2)

print()
print("(b1, b2) est une base car le rang de Q-I est 1 : la première colonne est nulle et pour les 2 autres, on a 2*C2 = C3. Donc la dimension de Ker(Q-I) est 2 et la famille (b1, b2) est libre, c'est donc une base du noyau")
print()

print("Pour déterminer la factorisation de f, on va utiliser b2 (car b1 est constant) auquel on va ajouter alpha dans F3 puis on va calculer le pgcd avec f")

facto = []
for alpha in [_sage_const_0 , _sage_const_1 , _sage_const_2 ] :
    g = gcd(f, x+x**_sage_const_2 +alpha)
    if g not in facto and g != _sage_const_1 :
        facto.append(g)
print("Factorisation de f :")
print(facto)
print()

def myB(f):
    Pol=f.parent()
    x=Pol.gen()
    p=Pol.base_ring().characteristic()
    q=Pol.base_ring().cardinality()
    n = f.degree()
    Fq = FiniteField(q)
    Q = matrix(Fq, n, n)
    for j in range (n) :
        modf = (x**(j*q) % f)
        for i in range (n) :
            Q[i, j] = modf[i]
    # print(Q)
    M = Q-identity_matrix(n)
    kerM = M.right_kernel()
    b = kerM.basis()
    # print(b)
    F = [f]
    j = _sage_const_0 
    while len(F) < len(b) :
        j += _sage_const_1 
        C = [fi for fi in F if fi.degree() > _sage_const_1 ]
        for fi in C :
            B = []
            for alpha in range(q) :
                # print(b[j])
                pol_bj = sum(b[j][l]*(x**l) for l in range (q))
                a = gcd(fi, pol_bj-alpha)
                if a.degree() > _sage_const_0  :
                    B.append(a)
            F.remove(fi)
            F += B
    # print(Set(F))
    assert(Set(F) == Set(g for g,_ in list(f.factor())))
    return F

Pol = PolynomialRing(FiniteField(_sage_const_7 ), names=('z',)); (z,) = Pol._first_ngens(1)
test = true
for _ in range (_sage_const_100 ) :
    f = Pol.random_element(_sage_const_1 , _sage_const_10 )
    f = z**(f.degree()) + sum(f[i]*z**i for i in range (f.degree()))
    try : 
        myB(f)
    except : # si un des assert est faux
        test = false 
        break 

print("Résultats de 100 tests aléatoires de l'algorithme de Berlekamp : ") 
print(test)
print()

def myFsFC(f):
    # fonction de factorisation sans facteurs carrés du TP4
    Pol=f.parent()
    x=Pol.gen()
    p=Pol.base_ring().characteristic()
    q=Pol.base_ring().cardinality()
    fp = f.derivative()
    if f == _sage_const_0  :
        return []
    elif fp != _sage_const_0  :
        i = _sage_const_1 
        L = []
        t = gcd(f, fp)
        u = f//t
        while u != _sage_const_1  :
            y = gcd(t, u)
            if i % p != _sage_const_0  and u//y != _sage_const_1  :
                L += [(u//y, i)]
            i += _sage_const_1 
            u = y
            t = t//y
        if t != _sage_const_1  :
            for (s, i) in myFsFC(racine_p_polynome(t)) :
                L += [(s, p*i)]
    else :
        for (s, i) in myFsFC(racine_p_polynome(f)) :
            L += [(s, p*i)]
    assert(prod([f**e for (f,e) in L]) == f)
    return L

def myFactor(f):
    Pol=f.parent()
    x=Pol.gen()
    p=Pol.base_ring().characteristic()
    q=Pol.base_ring().cardinality()
    L = myFsFC(f) # list des (gi, i)
    retour = []
    for (gi, i) in L :
        for p in myB(gi) :
            retour.append((p, i))
    assert(Set(retour) == Set(list(f.factor())))
    return retour


# # Affichage des resultats

Pol = PolynomialRing(FiniteField(_sage_const_7 ), names=('z',)); (z,) = Pol._first_ngens(1)
test = true
for _ in range (_sage_const_100 ) :
    f = Pol.random_element(_sage_const_1 , _sage_const_10 )
    f = z**(f.degree()) + sum(f[i]*z**i for i in range (f.degree()))
    try : 
        myFactor(f)
    except : # si un des assert est faux
        test = false 
        break 

print("Résultats de 100 tests aléatoires de l'algorithme de factorisation complet : ") 
print(test)
print()


print("""\
# ****************************************************************************
# RELEVEMENT DE HENSEL
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

PolZZ = PolynomialRing(ZZ, names=('x',)); (x,) = PolZZ._first_ngens(1)
m = _sage_const_5 
f = x**_sage_const_4 -_sage_const_1 
g = x**_sage_const_3 +_sage_const_2 *x**_sage_const_2 -x-_sage_const_2 
h = x-_sage_const_2 
d,ss,tt = xgcd(g,h)
s=PolZZ(ss/mod(d,m)); t=PolZZ(tt/mod(d,m))

# Code pour l'EXERCICE

def polynomeCentre(f,m):
    Pol=f.parent()
    x=Pol.gen()
    retour = Pol([mod(coeff,m).lift_centered() for coeff in list(f)])
    return retour

def modPol(p, m) :
    Pol=f.parent()
    x=Pol.gen()
    retour = Pol([mod(coeff,m) for coeff in list(p)])
    return retour

def myHensel(f,g,h,s,t,m):
    Pol=f.parent()
    x=Pol.gen()
    e = modPol(f - g*h, m*m)
    q = modPol((s*e) // h, m*m)
    r = modPol((s*e) % h, m*m)
    g_ = modPol(g+t*e+q*g, m*m)
    h_ = modPol(h+r, m*m)
    b = modPol(s*g_ + t*h_ - _sage_const_1 , m*m)
    c = modPol((s*b) // h_, m*m)
    d = modPol((s*b) % h_, m*m)
    s_ = modPol(s-d, m*m)
    t_ = t - t*b - c*g_ 
    g_ = polynomeCentre(g_, m*m)
    h_ = polynomeCentre(h_, m*m)
    s_ = polynomeCentre(s_, m*m)
    t_ = polynomeCentre(t_, m*m)
    return g_, h_, s_, t_

def myHenselItere(f,g,h,s,t,m,l):
    Pol=f.parent()
    x=Pol.gen()
    pow2t = _sage_const_1 
    while pow2t < l :
        m = (m*m)
        pow2t *= _sage_const_2 
        g, h, s, t = myHensel(f, g, h, s, t, m)
    return g, h, m, pow2t

reponseQ5="Si f se factorise en produit de plus de 2 facteurs, on peut appliquer n itérations ou n est le nombre de facteurs dans la décomposition. Soit gi un facteur premier avec les autres dans la décomposition de f, alors on écrit f = gi*h avec h produit d'autres facteurs, on applique Hensel et on a f = (gi)^ * h^ (mod p^l) puis on applique à h récursivement"

# # Affichage des resultats

print("\n$1b/ Relèvement de ",f,"= (",g,")*(",h,")")
print(myHensel(f,g,h,s,t,m))
print("\n Relèvement modulo 25 de ",f,"= (",g,")*(",h,")")
print(myHensel(f,g,h,s,t,m))
print("\n Relèvement modulo 625 de ",f,"= (",g,")*(",h,")")
print(myHenselItere(f,g,h,s,t,_sage_const_5 ,_sage_const_4 ))
print()
print(reponseQ5)
print()


print("""\
# ****************************************************************************
# FACTORISATION AVEC LLL
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

p=_sage_const_13 
k=_sage_const_4 
m=p**k

PolZZ = PolynomialRing(ZZ, names=('x',)); (x,) = PolZZ._first_ngens(1)
f = x**_sage_const_4 -x**_sage_const_3 -_sage_const_5 *x**_sage_const_2 +_sage_const_12 *x-_sage_const_6 

alpha=_sage_const_3 
beta=_sage_const_5 
gamma=_sage_const_8 
delta=_sage_const_11 

u = x+_sage_const_7626 

# Code pour l'EXERCICE


Pol13pow4 = PolynomialRing(Integers(m), names=('x',)); (x,) = Pol13pow4._first_ngens(1)
f_ = Pol13pow4(f)
rac_Z13pow4 = f_.roots(multiplicities=false)
rac_Z13pow4 = [r.lift_centered() for r in rac_Z13pow4]

alphahat = [z for z in rac_Z13pow4 if z%_sage_const_13  == alpha][_sage_const_0 ]
betahat = [z for z in rac_Z13pow4 if z%_sage_const_13  == beta][_sage_const_0 ]
gammahat = [z for z in rac_Z13pow4 if z%_sage_const_13  == gamma][_sage_const_0 ]
deltahat = [z for z in rac_Z13pow4 if z%_sage_const_13  == delta][_sage_const_0 ]

# # Affichage des resultats

print("$1a/ Les racines sont", alpha, beta, gamma, delta,"modulo",p)
F13 = FiniteField(_sage_const_13 )
Pol13 = PolynomialRing(F13, names=('z',)); (z,) = Pol13._first_ngens(1)
f = z**_sage_const_4 -z**_sage_const_3 -_sage_const_5 *z**_sage_const_2 +_sage_const_12 *z-_sage_const_6 
print(f.roots())

print("\n$1b/ Les racines sont", alphahat, betahat, gammahat, deltahat,"modulo",m)
print()

PolZZ = PolynomialRing(ZZ, names=('x',)); (x,) = PolZZ._first_ngens(1)
f = x**_sage_const_4 -x**_sage_const_3 -_sage_const_5 *x**_sage_const_2 +_sage_const_12 *x-_sage_const_6 


print("$1c) f mod x-alphahat : ", (f % (x-alphahat)))
print("f mod x-betahat : ", (f % (x-betahat)))
print("f mod x-gammahat : ", (f % (x-gammahat)))
print("f mod x-deltahat : ", (f % (x-deltahat)))
print()

uu = Pol13pow4(u)
test = (f_ % uu == _sage_const_0 )

d = u.degree()
j=_sage_const_3 

x = PolZZ.gen()
L = [u*PolZZ(x**i) for i in range(j-d)] + [m*PolZZ(x**i) for i in range(j)]
M = Matrix(ZZ, len(L), j, [[L[h][i] for i in range(j)] for h in range(len(L))])
LLL_basis = M.LLL()
i=_sage_const_0 
while not(any(LLL_basis[i,:])):
    i+=_sage_const_1 
vecteur_court = list(LLL_basis.row(i))
g = PolZZ(vecteur_court)
fact1 = gcd(g,f)
fact2 = f/fact1

print("$2a/ Si u divise f modulo 13^4 :", test)
print() 
print("$2b/ Facteur de f :", fact1)
print()
print("$2c/ Factorisation de f : f=(",fact1,")*(",fact2,")")

